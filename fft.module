<?php

/**
 * @file
 * Field formatter template.
 */


/**
 * Get real path with token.
 *
 * @param string $file
 *   File path. Use with {module-name} {theme-name} {theme} {fft}.
 *
 * @return string
 *   Real path.
 */
function fft_realpath($file, $template_file = '') {
  $file = trim($file);

  if (strpos($file, '{') === FALSE) {
    return $file;
  }

  if (strpos($file, '{fft}') !== FALSE) {
    $theme_path = dirname($template_file);
    $file = str_replace('{fft}', $theme_path, $file);
    return $file;
  }

  if (strpos($file, '{theme}') !== FALSE) {
    $theme_default = $GLOBALS['conf']['theme_default'];
    $theme_path = drupal_get_path('theme', $theme_default);
    $file = str_replace('{theme}', $theme_path, $file);
    return $file;
  }

  $matches = array();
  $types = array('module', 'theme', 'library');

  foreach ($types as $type) {
    $pattern = '/\{' . $type . '-(.+)\}/';

    preg_match($pattern, $file, $matches);

    if ($type == "library") {
      if (count($matches) > 1 && ($path = libraries_get_path($matches[1])) != '') {
        $file = str_replace($matches[0], $path, $file);
        return $file;
      }
    }
    else {
      if (count($matches) > 1 && ($path = drupal_get_path($type, $matches[1])) != '') {
        $file = str_replace($matches[0], $path, $file);
        return $file;
      }
    }
  }

  return $file;
}


/**
 * Clear up string.
 */
function fft_cleanup_header_comment($str) {
  return trim(preg_replace("/\s*(?:\*\/|\?>).*/", '', $str));
}

/**
 * Get avaiables templates.
 *
 * @return array
 *   List of Field formatter template.
 */
function fft_get_templates() {
  static $page_templates = NULL;
  if (!$page_templates) {
    $extension = fft_theme_extension();
    $files = file_scan_directory(fft_store_dir(), '/^.*'.$extension.'$/');
    foreach ($files as $full_path => $file) {
      $file_content = file_get_contents($full_path);
      $header = array();
      if (!preg_match('|Template Name:(.*)$|mi', $file_content, $header)) {
        continue;
      }
      $template_file = str_replace(fft_store_dir() . "/", '', $file->uri);
      $page_templates['templates'][$template_file] = fft_cleanup_header_comment($header[1]);
      $settings = array();
      if (preg_match('%/\*Settings:(.*?)\*/%s', $file_content, $settings)) {
        $page_templates['settings'][$template_file] = trim($settings[1]);
      }
    }
  }

  return $page_templates;
}

function fft_field_formatter_render($entity, $field_type, $items, $settings) {
  $data = array();
  $element = array();

  switch ($field_type) {
    case 'file':

      break;
    case 'image':
      foreach ($items as $delta => $item) {
        $image_uri = $item->entity->getFileUri();
        $image['uri']  = $image_uri;
        $image['path'] = file_create_url($image_uri);
        foreach (array('width', 'height', 'alt') as $key) {
          $image["$key"] = $item->$key;
        }
        for ($i=1; $i <= 2; $i++) {
          if (!empty($settings["image_style_{$i}"])) {
            $image_styled         = fft_field_styled_image_url($item, $settings["image_style_{$i}"]);
            $image["path_{$i}"]   = $image_styled['path'];
            $image["width_{$i}"]  = $image_styled['width'];
            $image["height_{$i}"] = $image_styled['height'];
          }
        }

        $data[] = $image;
      }

      break;

    case 'text':
    case 'text_long':
    case 'text_with_summary':
      foreach ($items as $delta => $item) {
        $data[] = array(
          'text' => $item->processed,
        );
      }

      break;

    default:
      foreach ($items as $delta => $item) {
        $data[] = $item->getValue();
      }

      break;
  }

  $output = '';
  if (!empty($data)) {
    $template_file = fft_store_dir() . "/" . $settings['template'];
    $settings_extras = drupal_parse_info_format($settings['settings']);
    $attached = array();
    foreach (array('js', 'css', 'library') as $item) {
      if (isset($settings_extras[$item])) {
        foreach ((array) $settings_extras[$item] as $key => $value) {
          if (is_string($value)) {
            $attached[$item][] = fft_realpath($value, $template_file);
          }
          else {
            $attached[$item][] = $value;
          }
        }
      }
    }
    $settings_extras = $attached + $settings_extras;

    $output = fft_render($template_file, array(
      'data'     => $data,
      'entity'   => $entity,
      'settings' => $settings_extras,
    ));

    $element[0] = array(
      '#markup'   => $output,
      '#attached' => $attached,
    );
  }

  return $element;
}

/**
 * Get image url with stylename.
 *
 * @param object $image
 *   Image uri.
 * @param string $style
 *   Image style name.
 *
 * @return string
 *   Return image url.
 */
function fft_field_styled_image_url($image, $style) {
  $image_infor = array();
  $style = image_style_load($style);
  $image_uri = $image->entity->getFileUri();
  $image_filepath = $style->buildUri($image_uri);
  $style->createDerivative($image_uri, $image_filepath);
  $image_infor['path'] = file_create_url($image_filepath);
  // Determine the dimensions of the styled image.
  $dimensions = array(
    'width' => $image->width,
    'height' => $image->height,
  );
  $style->transformDimensions($dimensions);
  $image_infor['width']  = $dimensions['width'];
  $image_infor['height'] = $dimensions['height'];

  return $image_infor;
}

function fft_theme_extension() {
  $extension = '.html.twig';
  global $theme_engine;
  if (isset($theme_engine)) {
    $extension_function = $theme_engine . '_extension';
    if (function_exists($extension_function)) {
      $extension = $extension_function();
    }
  }

  return $extension;
}

/**
 * Render template with variables.
 *
 * @param string $template_file
 *   Template name.
 * @param array $variables
 *   Variables for template.
 *
 * @return string
 *   Rendered template.
 */
function fft_render($template_file, $variables) {
  if (!is_file($template_file)) {
    return "";
  }
  $render_function = 'twig_render_template';

  global $theme_engine;
  if (isset($theme_engine)) {
    if (function_exists($theme_engine . '_render_template')) {
      $render_function = $theme_engine . '_render_template';
    }
  }

  return $render_function($template_file, $variables);
}

/**
 * Get store directory.
 *
 * @return string
 *   Path of store dicrectory.
 */
function fft_store_dir() {
  //return variable_get('fft_store_dir', "sites/all/formatter");
  return \Drupal::config('fft.settings')->get('fft_store_dir');
}

/**
 * Implements hook_filter_format_update().
 */
function fft_filter_format_update($format) {
  field_cache_clear();
}

/**
 * Implements hook_filter_format_disable().
 */
function fft_filter_format_disable($format) {
  field_cache_clear();
}

function fft_get_field_types() {
  return array_keys(\Drupal::service('plugin.manager.field.field_type')->getDefinitions());
}

/**
 * Implements hook_field_formatter_info_alter().
 */
function fft_field_formatter_info_alter(&$info) {
  $field_types = fft_get_field_types();
  $info['fft_formatter']['field_types'] = $field_types;
}


if (!function_exists('drupal_parse_info_format')) {
  /**
  * Parses data in Drupal's .info format.
  *
  * Data should be in an .ini-like format to specify values. White-space
  * generally doesn't matter, except inside values:
  * @code
  * key = value
  * key = "value"
  * key = 'value'
  * key = "multi-line
  * value"
  * key = 'multi-line
  * value'
  * key
  * =
  * 'value'
  * @endcode
  *
  * Arrays are created using a HTTP GET alike syntax:
  * @code
  * key[] = "numeric array"
  * key[index] = "associative array"
  * key[index][] = "nested numeric array"
  * key[index][index] = "nested associative array"
  * @endcode
  *
  * PHP constants are substituted in, but only when used as the entire value.
  * Comments should start with a semi-colon at the beginning of a line.
  *
  * @param $data
  * A string to parse.
  *
  * @return
  * The info array.
  *
  */
  function drupal_parse_info_format($data) {
    $info = array();
    $constants = get_defined_constants();

    if (preg_match_all('
      @^\s*                           # Start at the beginning of a line, ignoring leading whitespace
      ((?:
        [^=;\[\]]|                    # Key names cannot contain equal signs, semi-colons or square brackets,
        \[[^\[\]]*\]                  # unless they are balanced and not nested
      )+?)
      \s*=\s*                         # Key/value pairs are separated by equal signs (ignoring white-space)
      (?:
        ("(?:[^"]|(?<=\\\\)")*")|     # Double-quoted string, which may contain slash-escaped quotes/slashes
        (\'(?:[^\']|(?<=\\\\)\')*\')| # Single-quoted string, which may contain slash-escaped quotes/slashes
        ([^\r\n]*?)                   # Non-quoted string
      )\s*$                           # Stop at the next end of a line, ignoring trailing whitespace
      @msx', $data, $matches, PREG_SET_ORDER)) {
      foreach ($matches as $match) {
        // Fetch the key and value string.
        $i = 0;
        foreach (array('key', 'value1', 'value2', 'value3') as $var) {
          $$var = isset($match[++$i]) ? $match[$i] : '';
        }
        $value = stripslashes(substr($value1, 1, -1)) . stripslashes(substr($value2, 1, -1)) . $value3;

        // Parse array syntax.
        $keys = preg_split('/\]?\[/', rtrim($key, ']'));
        $last = array_pop($keys);
        $parent = &$info;

        // Create nested arrays.
        foreach ($keys as $key) {
          if ($key == '') {
            $key = count($parent);
          }
          if (!isset($parent[$key]) || !is_array($parent[$key])) {
            $parent[$key] = array();
          }
          $parent = &$parent[$key];
        }

        // Handle PHP constants.
        if (isset($constants[$value])) {
          $value = $constants[$value];
        }

        // Insert actual value.
        if ($last == '') {
          $last = count($parent);
        }
        $parent[$last] = $value;
      }
    }

    return $info;
  }
}
